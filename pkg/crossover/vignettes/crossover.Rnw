\documentclass[a4paper, 10pt]{article}
\usepackage{natbib}
\bibliographystyle{plainnat}
\usepackage[T1]{fontenc}
\usepackage{url}
 \usepackage[utf8]{inputenc}
\usepackage{graphicx}
%\usepackage{tikz}
%\usetikzlibrary{decorations,arrows,shapes}
\usepackage[margin=0.9in]{geometry}
\usepackage{url}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xspace}
\usepackage{tabularx}
\usepackage{makeidx}\makeindex
\usepackage{algorithmic} 
\usepackage{algorithm}
%\usepackage[left=3cm,right=3cm,top=2cm,bottom=2cm]{geometry}
\usepackage{amsmath,amsthm,amsfonts,amssymb}
\setlength{\parindent}{0mm}
\setlength{\parskip}{1mm}
\newcommand{\commentout}[1]{}
\renewcommand{\hlcomment}[1]{\textcolor[rgb]{0.4,0.4,0.4}{#1}}
\renewcommand{\theequation}{\thesection.\arabic{\equation}}
\numberwithin{equation}{section}

\theoremstyle{definition}
\newtheorem{Def}{Definition}[section]
\newtheorem{Rem}[Def]{Remark}
\newtheorem{RemDef}[Def]{Remark und Definition}
\newtheorem{DefRem}[Def]{Definition und Remark}
\newtheorem{Example}[Def]{Example}
\theoremstyle{plain}
\newtheorem{Theorem}[Def]{Theorem}
\newtheorem{DefTheorem}[Def]{Definition and Theorem}
\newtheorem{Corollary}[Def]{Corollary}
\newtheorem{Lemma}[Def]{Lemma}

\newcommand{\C}{\ensuremath{\mathbb{C}}\xspace}
\newcommand{\R}{\ensuremath{\mathbb{R}}\xspace}
\newcommand{\Q}{\ensuremath{\mathbb{Q}}\xspace}
\newcommand{\Z}{\ensuremath{\mathbb{Z}}\xspace}
\newcommand{\NN}{\ensuremath{\mathbb{N}_0}\xspace}
\newcommand{\N}{\ensuremath{\mathbb{N}}\xspace}
\newcommand{\sF}{\ensuremath{\mathcal{F}}\xspace}
\newcommand{\Pot}{\ensuremath{\mathfrak{Pot}}\xspace}
\newcommand{\kronecker}{\raisebox{1pt}{\ensuremath{\:\otimes\:}}}

\DeclareMathOperator{\range}{range}

\newcommand{\skp}[1]{\left\langle#1\right\rangle}

\renewcommand{\epsilon}{\varepsilon}
\renewcommand{\phi}{\varphi}
\newcommand{\id}{\text{id}}

\newenvironment{Proof}{\par\noindent\upshape\textit{Proof. }\nopagebreak}{\qed\par}

\usepackage{setspace}
\onehalfspacing

\begin{document}

%\VignetteEngine{knitr}
%\VignetteIndexEntry{crossover - A search algorithm and GUI for cross-over designs}

\title{crossover - A search algorithm and GUI for cross-over designs} 

\author{Kornelius Rohmeyer}

%\maketitle

%\newpage

%\tableofcontents

<<OptionsAndLibraries, include=FALSE, message=FALSE>>=
if (exists("opts_chunk")) {
  opts_chunk$set(concordance=TRUE)
  opts_chunk$set(tidy.opts=list(keep.blank.line=FALSE, width.cutoff=95))
  #opts_chunk$set(size="footnotesize")
  #opts_chunk$set(size="tiny")
  opts_chunk$set(size="scriptsize")  
}
library(crossover, quietly=TRUE)
options(width=128)
options(digits=4)
startGUI <- function(...) {invisible(NULL)}
#options(prompt="> ", continue="+ ")

@

\newpage

\section{Introduction}

This package provides more than two hundred cross-over design from literature, a search algorithm to find efficient cross-over designs for various models and a graphical user interface to find/generate appropriate designs.

The computationally intensive parts of the packe, i.e.\ the search algorithm, is written using the R packages Rcpp and RcppArmadillo (\cite{eddelbuettel2011rcpp} and \cite{rcpparmadillo}).

\subsection{Installation}

%If you don't already have R on your system, you can download a bundled
%version of R and crossover from \url{http://www.algorithm-forge.com/gMCP/bundle/}.

%Open R and type \texttt{install.packages("crossover")}, 
%select an arbitrary mirror and crossover will be downloaded and installed.

Once it is installed, whenever you start R you can load the crossover
package by entering \texttt{library(crossover)} into the R Console. The
graphical user interface as shown in figure \ref{GUI} is started with the command
\texttt{graphGUI()}.

\begin{figure}[ht]
  \centering    
  \includegraphics[width=0.7\textwidth]{figures/GUI.png}      
  \caption{\label{GUI} Cross-Over Design GUI.}
\end{figure}

%If you run into problems, see
%\url{http://cran.r-project.org/web/packages/gMCP/INSTALL} or please write us
%an email at
%\href{mailto:help@small-projects.de}{\texttt{help@small-projects.de}}.
%We are eager to help and to learn about existing problems.

\subsection{GUI Overview}
\subsubsection{Catalogue}
The catalogue, collected and compiled by Professor Byron Jones, contains 241 designs from the following literature: \cite{anderson2002locally}, \cite{archdeacon1980some}, \cite{atkinson1966designs}, \cite{balaam1968two}, \cite{berenblut1964change}, \cite{blaisdell1980partially}, \cite{davis1969cyclic}, \cite{federer1964tied}, \cite{fletcher1987new}, \cite{iqbal1994efficient}, \cite{lewis1988factorial}, \cite{cochran1941double}, \cite{patterson1962change}, \cite{pigeon1985residual}, \cite{prescott1999construction}, \cite{quenouille1953design}, \cite{russell1991construction}, \cite{lucas1956switchback}, \cite{williams1949experimental}, \cite{prescott1994}, \cite{bate2002}

%Anderson, I. and Preece, D.A. (2002) Locally balanced change-over designs. Utilitas Mathematica, 33-59. %TODO replace this "to appear" at other places too!
%Anderson, I. (2002) Personal communication.
%Archdeacon, D.S., Dinitz J.H., Stinson, D.R. and Tillson, T.W. (1980)
%Some new row-complete latin squares, Journal of Combinatorial Theory, Series A, 29, 395-398.
%Source: Atkinson, G.F. (1966) Designs for sequences of treatments with carry-over effects. Biometrics, 22, 292--309.
%Balaam, L.N. (1968) A two-period design with $t^2$ experimental units. Biometrics, 24, 61--73.
%Bate, S. and Jones, B. (2002) The construction of universally optimal uniform cross-over designs. GlaxoSmithKline Biomedical Data Sciences Technical Report 2002-06.
%Berenblut, I.I. (1964) Change-over designs with complete balance for residual effects. Biometrics, 23, 578--580.
%Blaisdell, E.A. and Raghavarao, D. (1980) Partially balanced change-over designs based on m-associate class PBIB designs. Journal of the Royal Statistical Society, B, 42, 334--338.
%Davis, A.W. and Hall, W.B. (1969) Cyclic change-over designs. Biometrika, 56, 283--293.
%Federer, W.T. and Atkinson, G.F. (1964) Tied-double-change-over designs. Biometrics, 20, 168--181.
%Fletcher, D.J. (1987) A new class of change-over designs for factorial experiments. Biometrika, 74, 649--654.
%Iqbal, I. and Jones, B. (1994) Efficient repeated measurements designs with equal and unequal period sizes. Journal of Statistical Planning and Inference, 42, 79-88.
%Factorial cross-over designs in clinical trials, Lewis, S.M., Fletcher, D.J. and Matthews, J.N.S. In Optimal Design and Analysis of Experiments, Editors, Dodge, Y., Fedorov, V.V. and Wynn, H.P. (1988), 133--140, Elsevier Science Publishers B.V. (North-Holland).
%Cochran, W.G., Autrey, K.M. and Cannon, C.Y. (1941) A double change-over design for dairy cattle feeding experiments. Journal of Dairy Science, 24, 937--951
%Patterson, H.D. and Lucas, H.L. (1962) Change-over designs. North Carolina Agricultural Experiment Station. Tech. Bull. No. 147.
%Patterson, H.D. and Lucas, H.L. (1962) Change-over designs. North Carolina Agricultural Experiment Station. Tech. Bull. No. 147.
%Residual effects designs for comparing treatments with a control. PhD dissertation, Temple University, Phildelphia, PA, 1984.
%Prescott, P. (1994) Construction of sequentially counterbalanced designs formed from two or more Latin Squares. Proceedings of the 11th Symposium on Computational Statistics held in Vienna, Austria. Editors Dutter, R. and Grossmann, W.,  Physica-Verlag: Heidelberg, 435-440.
%Prescott, P. (1999) Construction of sequentially counterbalanced designs formed from two latin squares. Utilitas Mathematica, 55, 135--152.
%Quenouille, M.H. (1953) The Design and Analysis of Experiments. Griffin, London.
%Russell, K.R. (1991) The construction of good change-over designs when there are fewer units than treatments. Biometrika, 78, 305-313.
%Lucas, H.L. (1956) Switch-back trials for more than two treatments. Journal of Diary Science, 39, 146--154.
%Williams, E.J. (1949) Experimental designs balanced for the estimation of residual effects of treatments. Australian Journal of Science Res(A), 2, 14900168.

Depending on the numbers of treatments, periods and range of sequence you specify in the GUI appropriate designs from the catalogue will be shown.\footnote{You can get a table referencing all designs and the respective number of treatments, periods and sequences by calling \texttt{buildSummaryTable()}.} Further if possible functions from package crossdes \cite{crossdes} are called to create design for the specified values.

\subsubsection{Algorithm Search}

In figure \ref{Algorithm} the preliminary graphical interface for the search algorithm is shown with the following options:
\begin{itemize}
  \item The drop-down menu for \emph{model} let you specify which model you are interested. These models are described in detail in section \ref{sec:models}.
  \item In case of the placebo or proportionality model you can specify \emph{further model parameters} (namely the number of placebos and the proportionality parameter, respectively).
  \item %While the number of treatments and periods is taken 
    Specify the exact \emph{number of sequences}. (The number of treatments and periods is already specified in the top panel of the GUI.)
  \item Specify \emph{how often each treatment should be assigned}. The GUI default is to assign the treatments as evenly as possible, but depending on further information (is there a control group that should have greater weight or are there treatments more important than the others?) other assignments should be used.
  \item You can specify that the design should be constructed in a way that \emph{in each sequence/period a treatment occur as evenly as possible}. This restriction will normally decrease the efficiency of the algorithm.
  \item The GUI default is an all-pair comparison of all treatments with equal weights. Change the \emph{contrast weights} accordingly if you are interested in other contrasts or different weights.
  \item Pressing the \emph{"Compute Design"} button will start the search algorithm described in section \ref{sec:search}. After a few seconds the result will be shown in the previous empty text area on the right.
\end{itemize}

\begin{figure}[ht]
  \centering    
  \includegraphics[width=0.7\textwidth]{figures/Algorithm.png}      
  \caption{\label{Algorithm} Panel for algorthmic search of cross-over designs.}
\end{figure}

\subsubsection{Input own design}

This tab provides you with the possibility to analyse your own designs easily or use them as starting points for the search algorithm.

\section{Models}\label{sec:models}

The package and GUI support the following eight models.

\subsection{Standard additive model}\index{model!standard additive}

\[Y_{ijk}=\mu+\pi_j+\tau_{d[i,j]}+\lambda_{d[i,j-1]}+s_{ik}+e_{ijk}\]

with\footnote{cf. \cite{jones2003design}, page 8}

\begin{description}
  \item[$\mu$] intercept,
  \item[$\pi_j$] period effect for period $j$,
  \item[$\tau_{d[i,j]}$] direct treatment effect for treatment $d[i,j]$ in period $j$ of sequence $i$,
  \item[$\lambda_{d[i,j-1]}$] first-order carry-over effect (0 for $j-1$=0),
  \item[$s_{ik}$] $k$th subject effect on sequence $i$, %TODO What is the most elegant way to handle this? We only need/want s_i?
  \item[$e_{ijk}$] random error with zero mean and variance $\sigma^2$.
\end{description}

which we can write as

\[E(Y)=\mu + X \bigl( \begin{smallmatrix}
\tau\\ \lambda
\end{smallmatrix} \bigr)+Z\bigl( \begin{smallmatrix}
\pi\\ s
\end{smallmatrix} \bigr)\]

with $X$ and $Z$ called the \emph{treatment}\index{treatment design matrix} and \emph{block design matrices}\index{block design matrix}, respectively.

We call $H$ a \emph{link matrix}\index{link matrix} if $X=X_rH$ were $X_r$ is the design matrix for the row-column design.
The rows of the link matrix specify all possible parameter combinations.

<<StandardAdditive, echo=TRUE>>=
# Design:
design <- rbind(c(3,2,1),
                c(2,1,3),
                c(1,2,3),
                c(3,2,1))
design
v <- 3 # number of treatments
# Link matrix:
H <- crossover:::linkMatrix(model="Standard additive model", v)
H
# Row-Column-Design: (cf. John et al. 2004, Table II and page 2649f.)
rcDesign <- crossover:::createRowColumnDesign(design, model=1)
rcDesign
# Design Matrix of Row-Column Design:
Xr <- crossover:::getRCDesignMatrix(rcDesign, v+v*v)
Xr
# Design Matrix of Cross-Over Design:
X <- Xr %*% H
X

@

\subsection{Full set of interactions}\index{model!with full set of interactions}

This model has further interaction parameters $\gamma_{ij}$.\footnote{Personally I think some of the overspecified parameters should be dropped, for example $\gamma_{ii}$ - but I'll take a look at this later.}

\[E(Y)=\mu + X \left( \begin{smallmatrix}
\tau\\ \lambda\\ \gamma
\end{smallmatrix} \right)+Z\bigl( \begin{smallmatrix}
\pi\\ s
\end{smallmatrix} \bigr)\]

<<FullInteractions, echo=TRUE>>=

H <- crossover:::linkMatrix(model="Full set of interactions", v)
H
# Design Matrix of Cross-Over Design:
X <- Xr %*% H
X

@

\subsection{Self-adjacency model}\index{model!self-adjacency model}\index{self-adjacency model}

In the \emph{self-adjacency model} $\lambda_i$ is replaced by $\phi_i$ in case of carry-over into itself. The case $\phi=0$ represents the \emph{no carry-over into self model}.

\[E(Y)=\mu + X \bigl( \begin{smallmatrix}
\tau\\ \lambda\\ \phi
\end{smallmatrix} \bigr)+Z\bigl( \begin{smallmatrix}
\pi\\ s
\end{smallmatrix} \bigr)\]

<<SelfAdjacency, echo=TRUE>>=

H <- crossover:::linkMatrix(model="Self-adjacency model", v)
H
# Design Matrix of Cross-Over Design:
X <- Xr %*% H
X

@

\subsection{Placebo model}\index{model!placebo model}\index{model!placebo model}

In the placebo model there are no carry-over effects for the placebo treatment(s).

\[E(Y)=\mu + X \bigl( \begin{smallmatrix}
\tau\\ \lambda
\end{smallmatrix} \bigr)+Z\bigl( \begin{smallmatrix}
\pi\\ s
\end{smallmatrix} \bigr)\]

(I would drop the $0$ column and provide another row-column design matrix... (and apart from consistency - is this really unproblematic?! TODO))

<<echo=TRUE, eval=TRUE>>=
# Link matrix:
H <- crossover:::linkMatrix(model="Placebo model", v, placebos=1)
H
# Design Matrix of Cross-Over Design:
X <- Xr %*% H
X

@

\subsection{No carry-over into self model}\index{model!no carry-over into self}

This model differs from the standard additive model in the assumption that in the \emph{no carry-over into self model} no carry-over effect occurs if current and previous treatment are the same.

\[E(Y)=\mu + X \bigl( \begin{smallmatrix}
\tau\\ \lambda
\end{smallmatrix} \bigr)+Z\bigl( \begin{smallmatrix}
\pi\\ s
\end{smallmatrix} \bigr)\]

<<NoIntoSelf, echo=TRUE>>=

H <- crossover:::linkMatrix(model="No carry-over into self model", v)
H
# Design Matrix of Cross-Over Design:
X <- Xr %*% H
X

@

\subsection{Treatment decay model}\index{model!treatment decay}

In contrast to the no carry-over into self model in the \emph{treatment decay model} we assume there are only (negative) carry-over effects if the current and previous treatment are the same.

\[E(Y)=\mu + X \bigl( \begin{smallmatrix}
\tau\\ \lambda
\end{smallmatrix} \bigr)+Z\bigl( \begin{smallmatrix}
\pi\\ s
\end{smallmatrix} \bigr)\]

<<TreatmentDecay, echo=TRUE>>=

H <- crossover:::linkMatrix(model="Treatment decay model", v)
H
# Design Matrix of Cross-Over Design:
X <- Xr %*% H
X

@

\subsection{Proportionality model}\index{model!proportionality model}

For the proportionality model we have no separate carry-over effects, but assume for period $i>1$ an additive proportion $p$ of the effect $\tau_{d(i-1,j)}$ from the previous treatment $d(i-1,j)$. This model is non-linear in $p$, therefore we assume $p$ is known.

\[E(Y)=\mu + X_p\tau +Z\bigl( \begin{smallmatrix}
\pi\\ s
\end{smallmatrix} \bigr)\]

<<Proportionality, echo=TRUE>>=

H <- crossover:::linkMatrix(model="Proportionality model", v)
H
# Design Matrix of Cross-Over Design:
X <- Xr %*% H
X

@

\subsection{Second-order carry-over effects}\index{model!with second-order carry-over effects}\index{second-order carry-over effects}

In the model with second-order carry-over effects we do have another vector $\lambda_2$ of carry-over effects:

\[E(Y)=\mu + X \left( \begin{smallmatrix}
\tau\\ \lambda_1\\ \lambda_2
\end{smallmatrix} \right)+Z\bigl( \begin{smallmatrix}
\pi\\ s
\end{smallmatrix} \bigr)\]

Therefore the link matrix has $3*v$ columns. % and we calculate the row-column design

<<SecondOrder, echo=TRUE>>=
# Link matrix:
H <- crossover:::linkMatrix(model="Second-order carry-over effects", v)
H
# Row-Column-Design: (cf. John et al. 2004, Table II and page 2649f.)
rcDesign <- crossover:::createRowColumnDesign(design, model=8)
rcDesign
# Design Matrix of Row-Column Design:
Xr <- crossover:::getRCDesignMatrix(rcDesign, v+v^2+v^3)
Xr
# Design Matrix of Cross-Over Design:
X <- Xr %*% H
X

@


\section{Search strategy}\label{sec:search}
Monte-Carlo search for first candidates, followed by parallel hill climbing search, extended by long jumps. (Blind movement, probabilistic movement?)

In the following graphic we see 100.000 design evaluations (that take less than 7 seconds on my computer), consisting out of 20 hill climbing search \emph{runs} from 20 different designs as starting point which were selected by a Monte-Carlo search. We can see that 6 out of the 20 search runs were not able to achieve the efficieny the other 14 achieved. With search run 15 again not as good as the rest, we see that there were at least three local maxima the hill climbing search found (and partially got stuck):

<<SearchStrategy, echo=TRUE, eval=TRUE, cache=TRUE>>=

set.seed(42)
x <- searchCrossOverDesign(s=9, p=5, v=4, model=4, eff.factor=1)
searchPlot(x)
searchPlot(x, type=2)

@

%For a given cross-over design we create a row-column design, calculate the information matrix $A_r$ for this design from
%\[A_r=r^\delta-\tfrac{1}{s}N_pN_p'-\tfrac{1}{p}N_sN_s'+\tfrac{1}{ps}rr'.\]
%For details see \cite{j1995cyclic} and \cite{john2004crossover}.

\subsection{Evaluation of Algorithm Performance}

%\begin{Example}
% Lorem ipsum
%\end{Example}

Let's compare the results from the search algorithm with results from the literature.

<<eval1, echo=TRUE, eval=TRUE>>=
 # We will use a lot of internal commands since we will test and evaluate things the normal user will probably not be interested in. Therefore we load and attach the namespace.
 attach(loadNamespace("crossover"), name="namespace:crossover", pos=3)


@

There are different approaches to calculate the Information matrix $A_r$ of the row-column design.
In the following code fragment we compare the two different approaches:

\[A_r=r^\delta-\tfrac{1}{s}N_pN_p'-\tfrac{1}{p}N_sN_s'+\tfrac{1}{ps}rr' \text{ and }\]
\[A_r=X_r'(I-P_z)X_r.\]
For details (what is $N_p$, $N_s$, $P_z$, etc.) see \cite{j1995cyclic} and \cite{john2004crossover}.

<<TestOfDifferentApproaches, echo=TRUE, eval=TRUE>>=
  s <- 3
  p <- 4
  v <- 3
  
  v.rep <- rep((s*p) %/% v, v) + c(rep(1, (s*p) %% v), rep(0, v-((s*p) %% v)))
  design <- matrix(sample(rep(1:v, v.rep)), p, s)
  
  rcDesign <- createRowColumnDesign(design, model=1)
  # JRW, p 2650, first equation on that page, whithout number
  Ar <- getInfMatrixOfDesign(rcDesign, v+v*v)
  Xr <- getRCDesignMatrix(rcDesign, v+v*v)
  # JRW, p 2650, second equation on that page, number 11
  Ar2 <- t(Xr) %*% (diag(s*p)-crossover:::getPZ(s,p)) %*% Xr
  max(abs(Ar-Ar2))

@
  
In the following code chunk we will compare the results from our approach in the search function with the results from the function \texttt{general.carryover}.

\begin{Def}[Efficiency]
  If the difference of two treatments, each replicated r times, is estimated in an \emph{ideal design} with residual variance $\sigma^2$, the variance of the estimated difference $\overline{y}\!_A-\overline{y}\!_B$ is
  \[V_I=\frac{2\sigma^2}{r}.\]
  In a cross-over design the variance of a parameter estimates for $A$ and $B$ are given by the corresponding elements $\sigma^2x_A$ and $\sigma^2x_A$ of
  \[\sigma^2(X^TX)^{-1}\]
  with $X$ the crossover design matrix. The variance of the difference is $\sigma^2 (x_A + x_B - 2*x_{AB})$ where $x_{AB}$ is the element of $X^TX$ specifying the covariance of the two treatment parameter estimates.
  The efficiency is \[E:=\frac{V_I}{V_C}=\frac{2}{rx}\;\in[0,1].\]
\end{Def}
  
<<TestWithGeneral.carryover, echo=TRUE, eval=TRUE>>=
  Csub <- contrMat(n=rep(1, v), type="Tukey")
  class(Csub) <- "matrix"
  C2 <- as.matrix(bdiag(Csub,Csub))
  C3 <- as.matrix(bdiag(Csub,Csub,Csub))
  C5 <- as.matrix(bdiag(Csub,matrix(0,dim(Csub)[1],4*v)))

  rcDesign <- createRowColumnDesign(design, model=8)
  # JRW, p 2650, first equation on that page, whithout number
  Ar3 <- getInfMatrixOfDesign(rcDesign, v+v^2+v^3)

  for (model in c(1,2,3,4,5,6,7,8)) {
    cat(models[model],":\n")
    if (model %in% c(2,8)) {
      #C <- C3
      C <- as.matrix(cbind(Csub, matrix(0, dim(Csub)[2], 2*v)))
    } else if (model==3) {
      C <- Csub      
    } else if (model==7) {
      C <- C5
    } else {
      #C <- C2
      C <- as.matrix(cbind(Csub, matrix(0, dim(Csub)[2], v)))
    }
    if (model==8) {
      Ar <- Ar3
    } else {
      Ar <- Ar2
    }    
    H <- linkMatrix(model=model, v)
    var1 <- sum(diag(C %*% ginv(t(H) %*% Ar %*% H) %*% t(C)))
    cat(diag(C %*% ginv(t(H) %*% Ar %*% H) %*% t(C)),"\n")
  
    gco <- general.carryover(t(design), model=model)
    print(gco$Var.trt.pair)
    if (model %in% c(2,8)) {      
      var2 <- sum(gco$Var.trt.pair[lower.tri(gco$Var.trt.pair)]) #+ sum(gco$Var.car.pair.1[lower.tri(gco$Var.car.pair.1)]) + sum(gco$Var.car.pair.2[lower.tri(gco$Var.car.pair.2)])
    } else if (model %in% c(3,7)) {
      var2 <- sum(gco$Var.trt.pair[lower.tri(gco$Var.trt.pair)])
    } else {
      var2 <- sum(gco$Var.trt.pair[lower.tri(gco$Var.trt.pair)]) #+ sum(gco$Var.car.pair[lower.tri(gco$Var.car.pair)])
    }
  
    cat("Difference: ",abs(var1-var2),"\n\n")
  }
@

  
<<TestWithGeneral.carryover2, echo=TRUE, eval=TRUE>>=
  data(atkinson)
  design <- atkinson3t
  Csub <- contrMat(n=rep(1, v), type="Tukey")
  class(Csub) <- "matrix"
  C2 <- as.matrix(bdiag(Csub,Csub))
  C3 <- as.matrix(bdiag(Csub,Csub,Csub))
  C5 <- as.matrix(bdiag(Csub,matrix(0,dim(Csub)[1],4*v)))

  
  # JRW, p 2650, first equation on that page, whithout number
  rcDesign <- createRowColumnDesign(design, model=1)
  Ar2 <- getInfMatrixOfDesign(rcDesign, v+v^2)
  rcDesign <- createRowColumnDesign(design, model=8)
  Ar3 <- getInfMatrixOfDesign(rcDesign, v+v^2+v^3)

  for (model in c(1,2,3,4,5,6,7,8)) {
    cat(models[model],":\n")
    if (model %in% c(2,8)) {
      #C <- C3
      C <- as.matrix(cbind(Csub, matrix(0, dim(Csub)[2], 2*v)))      
    } else if (model==3) {
      C <- Csub      
    } else if (model==7) {
      C <- C5
    } else {      
      C <- as.matrix(cbind(Csub, matrix(0, dim(Csub)[2], v)))      
    }
    if (model==8) {
        Ar <- Ar3
      } else {
        Ar <- Ar2
      }
    H <- linkMatrix(model=model, v)
    var1 <- sum(diag(C %*% ginv(t(H) %*% Ar %*% H) %*% t(C)))
    cat(diag(C %*% ginv(t(H) %*% Ar %*% H) %*% t(C)),"\n")
  
    gco <- general.carryover(t(design), model=model)
    print(gco$Var.trt.pair)
    if (model %in% c(2,8)) {      
      var2 <- sum(gco$Var.trt.pair[lower.tri(gco$Var.trt.pair)]) #+ sum(gco$Var.car.pair.1[lower.tri(gco$Var.car.pair.1)]) + sum(gco$Var.car.pair.2[lower.tri(gco$Var.car.pair.2)])
    } else if (model %in% c(3,7)) {
      var2 <- sum(gco$Var.trt.pair[lower.tri(gco$Var.trt.pair)])
    } else {
      var2 <- sum(gco$Var.trt.pair[lower.tri(gco$Var.trt.pair)]) #+ sum(gco$Var.car.pair[lower.tri(gco$Var.car.pair)])
    }
  
    cat("Difference: ",abs(var1-var2),"\n\n")
  }
@

  
<<TestWithGeneral.carryover3, echo=TRUE, eval=TRUE>>=
  p <- 8
  s <- 10
  v.rep <- rep((s*p) %/% v, v) + c(rep(1, (s*p) %% v), rep(0, v-((s*p) %% v)))
  design <- matrix(unlist(tapply(rep(1:v, v.rep), as.factor(rep(1:s,p)), sample)), p, s)
  print(design)
  Csub <- contrMat(n=rep(1, v), type="Tukey")
  class(Csub) <- "matrix"
  C2 <- as.matrix(bdiag(Csub,Csub))
  C3 <- as.matrix(bdiag(Csub,Csub,Csub))
  C5 <- as.matrix(bdiag(Csub,matrix(0,dim(Csub)[1],4*v)))

  
  # JRW, p 2650, first equation on that page, whithout number
  rcDesign <- createRowColumnDesign(design, model=1)
  Ar2 <- getInfMatrixOfDesign(rcDesign, v+v^2)
  rcDesign <- createRowColumnDesign(design, model=8)
  Ar3 <- getInfMatrixOfDesign(rcDesign, v+v^2+v^3)

  for (model in c(1,2,3,4,5,6,7,8)) {
    cat(models[model],":\n")
    if (model %in% c(2,8)) {      
      C <- as.matrix(cbind(Csub, matrix(0, dim(Csub)[2], 2*v)))      
      C <- C3
    } else if (model==3) {
      C <- Csub      
    } else if (model==7) {
      C <- C5
    } else {      
      C <- as.matrix(cbind(Csub, matrix(0, dim(Csub)[2], v)))   
      C <- C2
    }
    if (model==8) {
        Ar <- Ar3
      } else {
        Ar <- Ar2
      }
    H <- linkMatrix(model=model, v)
    var1 <- sum(diag(C %*% ginv(t(H) %*% Ar %*% H) %*% t(C)))
    cat(diag(C %*% ginv(t(H) %*% Ar %*% H) %*% t(C)),"\n")
  
    gco <- general.carryover(t(design), model=model)
    print(gco$Var.trt.pair)
    if (model %in% c(2,8)) {      
      var2 <- sum(gco$Var.trt.pair[lower.tri(gco$Var.trt.pair)]) + sum(gco$Var.car.pair.1[lower.tri(gco$Var.car.pair.1)]) + sum(gco$Var.car.pair.2[lower.tri(gco$Var.car.pair.2)])
      print(gco$Var.car.pair.1) 
      print(gco$Var.car.pair.2)
    } else if (model %in% c(3,7)) {
      var2 <- sum(gco$Var.trt.pair[lower.tri(gco$Var.trt.pair)])
    } else {
      var2 <- sum(gco$Var.trt.pair[lower.tri(gco$Var.trt.pair)]) + sum(gco$Var.car.pair[lower.tri(gco$Var.car.pair)])
      print(gco$Var.car.pair)
    }
  
    cat("Difference: ",abs(var1-var2),"\n\n")
  }
@


\begin{appendix} 

\section{Appendix - Row-Column Designs}

%\begin{Def}[Familywise Error Rate]\index{familywise error rate}
%  Let $H_J:=\bigcap_{j\in J} H_j$. The multiple test procedure $\phi$
%\end{Def}

This section is work in progress.

%\begin{Theorem}[Closed testing principle]\index{closed testing principle}
% \cite{marcus1976closed}
%\end{Theorem}

\end{appendix}

\nocite{*}

\newpage

\addcontentsline{toc}{section}{Index}
\printindex

%\newpage
%\listofalgorithms
%\listoffigures
%\listoftables

\newpage

\addcontentsline{toc}{section}{Literatur}
\bibliography{literatur}

\addcontentsline{toc}{section}{Table of Symbols}
\section*{Table of Symbols}\footnotesize
%\twocolumn[\section{Symbolverzeichnis}]
\begin{tabularx}{\textwidth}{lX}
\multicolumn{2}{l}{\textbf{Sets}}\\
\R& set of real numbers\\
\NN& set of natural numbers (including 0)\\
$\Pot(X)$ & power set of set $X$, i.e.\ the set of all subsets of $X$\\
\\
\multicolumn{2}{l}{\textbf{Variables}}\\
$v$& number of treatments\\
$p$& number of periods\\
$s$& number of sequences\\
$\mu$& intercept\\
$\pi_j$& period effect for period $j$\\
$\tau_{d[i,j]}$& direct treatment effect for treatment $d[i,j]$ in period $j$ of sequence $i$\\
$\lambda_{d[i,j-1]}$& first-order carry-over effect (0 for $j-1$=0)\\
$s_{ik}$& $k$th subject effect on sequence $i$\\
$e_{ijk}$& random error with zero mean and variance $\sigma^2$\\
%\end{tabularx}\\
%\begin{tabularx}{\textwidth}{lX}
\multicolumn{2}{l}{\textbf{Functions}}\\
$X'$ & transpose of matrix $X$\\
$\skp{\cdot,\cdot}$ & standard direct product $\skp{x,y}=\sum_{j=1}^nx_j\cdot y_j$ for $x,y\in\R^n$\\
$\id_X$ & identity on $X$, i.e.\ $\id_X:\;X\rightarrow X,\;x\mapsto x$\\
%\\
%\multicolumn{2}{l}{\textbf{Andere Symbole}}\\
\end{tabularx}
%\onecolumn

\normalsize

\newpage

\end{document}
